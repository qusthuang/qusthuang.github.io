<div class="Blog_wz1" style="word-wrap: break-word;">

	<span style="font-size:14.0pt;line-height:120%;font-family:黑体;">1<span>&nbsp; </span>ZeroMQ</span><span style="font-size:14.0pt;line-height:120%;font-family:黑体;">概述<span></span></span>

	<span>ZeroMQ</span><span style="font-family:宋体;">是一种基于消息队列的多线程网络库，其对套接字类型、连接处理、帧、甚至路由的底层细节进行抽象，提供跨越多种传输协议的套接字。</span><span>ZeroMQ</span><span style="font-family:宋体;">是网络通信中新的一层，介于应用层和传输层之间（按照</span><span>TCP/IP</span><span style="font-family:宋体;">划分），其是一个可伸缩层，可并行运行，分散在分布式系统间。</span>

	<span style="font-size:14.0pt;line-height:120%;font-family:黑体;">2<span>&nbsp; </span></span><span style="font-size:14.0pt;line-height:120%;font-family:黑体;">系统架构<span></span></span>

	<span style="font-size:12.0pt;line-height:120%;font-family:黑体;">2.1<span> </span></span><span style="font-size:12.0pt;line-height:120%;font-family:黑体;">总体架构<span></span></span>

	<span>ZeroMQ</span><span style="font-family:宋体;">几乎所有的</span><span>I/O</span><span style="font-family:宋体;">操作都是异步的，主线程不会被阻塞。</span><span>ZeroMQ</span><span style="font-family:宋体;">会根据用户调用</span><span>zmq_init</span><span style="font-family:宋体;">函数时传入的接口参数，创建对应数量的</span><span>I/O Thread</span><span style="font-family:宋体;">。每个</span><span>I/O Thread</span><span style="font-family:宋体;">都有与之绑定的</span><span>Poller</span><span style="font-family:宋体;">，</span><span>Poller</span><span style="font-family:宋体;">采用经典的</span><span>Reactor</span><span style="font-family:宋体;">模式实现，</span><span>Poller</span><span style="font-family:宋体;">根据不同操作系统平台使用不同的网络</span><span>I/O</span><span style="font-family:宋体;">模型（</span><span>select</span><span style="font-family:宋体;">、</span><span>poll</span><span style="font-family:宋体;">、</span><span>epoll</span><span style="font-family:宋体;">、</span><span>devpoll</span><span style="font-family:宋体;">、</span><span>kequeue</span><span style="font-family:宋体;">等）。主线程与</span><span>I/O</span><span style="font-family:宋体;">线程通过</span><span>Mail Box</span><span style="font-family:宋体;">传递消息来进行通信。</span><span>Server</span><span style="font-family:宋体;">开始监听或者</span><span>Client</span><span style="font-family:宋体;">发起连接时，在主线程中创建</span><span>zmq_connecter</span><span style="font-family:宋体;">或</span><span>zmq_listener</span><span style="font-family:宋体;">，通过</span><span>Mail Box</span><span style="font-family:宋体;">发消息的形式将其绑定到</span><span>I/O</span><span style="font-family:宋体;">线程，</span><span>I/O</span><span style="font-family:宋体;">线程会把</span><span>zmq_connecter</span><span style="font-family:宋体;">或</span><span>zmq_listener</span><span style="font-family:宋体;">添加到</span><span>Poller</span><span style="font-family:宋体;">中用以侦听读</span><span>/</span><span style="font-family:宋体;">写事件。</span><span>Server</span><span style="font-family:宋体;">与</span><span>Client</span><span style="font-family:宋体;">在第一次通信时，会创建</span><span>zmq_init</span><span style="font-family:宋体;">来发送</span><span>identity</span><span style="font-family:宋体;">，用以进行认证。认证结束后，双方会为此次连接创建</span><span>Session</span><span style="font-family:宋体;">，以后双方就通过</span><span>Session</span><span style="font-family:宋体;">进行通信。每个</span><span>Session</span><span style="font-family:宋体;">都会关联到相应的读</span><span>/</span><span style="font-family:宋体;">写管道，</span> <span style="font-family:宋体;">主线程收发消息只是分别从管道中读</span><span>/</span><span style="font-family:宋体;">写数据。</span><span>Session</span><span style="font-family:宋体;">并不实际跟</span><span>kernel</span><span style="font-family:宋体;">交换</span><span>I/O</span><span style="font-family:宋体;">数据，而是通过</span><span>plugin</span><span style="font-family:宋体;">到</span><span>Session</span><span style="font-family:宋体;">中的</span><span>Engine</span><span style="font-family:宋体;">来与</span><span>kernel</span><span style="font-family:宋体;">交换</span><span>I/O</span><span style="font-family:宋体;">数据。</span>

	<span>![](/attachment/201303/31/22312037_1364724942uQqB.png)

</span>

	<span style="font-size:9.0pt;line-height:120%;font-family:黑体;">图<span>1<span> </span></span>总体架构<span></span></span>

	<span style="font-size:12.0pt;line-height:120%;font-family:黑体;">2.2<span> </span></span><span style="font-size:12.0pt;line-height:120%;font-family:黑体;">所处层次<span></span></span>

	<span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>ZeroMQ</span><span style="font-family:宋体;">不是单独的服务或者程序，仅仅是一套组件，其封装了网络通信、消息队列、线程调度等功能，向上层提供简洁的</span><span>API</span><span style="font-family:宋体;">，应用程序通过加载库文件，调用</span><span>API</span><span style="font-family:宋体;">函数来实现高性能网络通信。</span>

	<span>![](/attachment/201303/31/22312037_136472497950Yy.png)

</span>

	<span style="font-size:9.0pt;line-height:120%;font-family:黑体;">图<span>2<span> </span></span>所处层次<span></span></span>

	<span style="font-size:12.0pt;line-height:120%;font-family:黑体;">2.3<span> </span></span><span style="font-size:12.0pt;line-height:120%;font-family:黑体;">消息模型<span></span></span>

	<span>ZeroMQ</span><span style="font-family:宋体;">将消息通信分成</span><span>4</span><span style="font-family:宋体;">种模型，分别是一对一结对模型（</span><span>Exclusive-Pair</span><span style="font-family:宋体;">）、请求回应模型（</span><span>Request-Reply</span><span style="font-family:宋体;">）、发布订阅模型（</span><span>Publish-Subscribe</span><span style="font-family:宋体;">）、推拉模型（</span><span>Push-Pull</span><span style="font-family:宋体;">）。这</span><span>4</span><span style="font-family:宋体;">种模型总结出了通用的网络通信模型，在实际中可以根据应用需要，组合其中的</span><span>2</span><span style="font-family:宋体;">种或多种模型来形成自己的解决方案。</span>

	<span style="font-family:黑体;">2.3.1<span>&nbsp;&nbsp; </span></span><span style="font-family:黑体;">一对一结对模型<span></span></span>

	<span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="font-family:宋体;">最简单的</span><span>1:1</span><span style="font-family:宋体;">消息通信模型，可以认为是一个</span><span>TCP
Connection</span><span style="font-family:宋体;">，但是</span><span>TCP Server</span><span style="font-family:宋体;">只能接受一个连接。数据可以双向流动，这点不同于后面的请求回应模型。</span>

	<span style="font-family:黑体;">2.3.2<span>&nbsp;&nbsp; </span></span><span style="font-family:黑体;">请求回应模型<span></span></span>

	<span style="font-family:宋体;">由请求端发起请求，然后等待回应端应答。一个请求必须对应一个回应，从请求端的角度来看是发</span><span>-</span><span style="font-family:宋体;">收配对，从回应端的角度是收</span><span>-</span><span style="font-family:宋体;">发对。跟一对一结对模型的区别在于请求端可以是</span><span>1~N</span><span style="font-family:宋体;">个。该模型主要用于远程调用及任务分配等。</span><span>Echo</span><span style="font-family:宋体;">服务就是这种经典模型的应用。</span>

	<span>![](/attachment/201303/31/22312037_1364725006a6xZ.png)

</span>

	<span style="font-size:9.0pt;line-height:120%;font-family:黑体;">图<span>3<span> </span></span>请求回应模型<span></span></span>

	<span style="font-family:黑体;">2.3.3<span>&nbsp;&nbsp; </span></span><span style="font-family:黑体;">发布订阅模型<span></span></span>

	<span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="font-family:宋体;">发布端单向分发数据，且不关心是否把全部信息发送给订阅端。如果发布端开始发布信息时，订阅端尚未连接上来，则这些信息会被直接丢弃。订阅端未连接导致信息丢失的问题，可以通过与请求回应模型组合来解决。订阅端只负责接收，而不能反馈，且在订阅端消费速度慢于发布端的情况下，会在订阅端堆积数据。该模型主要用于数据分发。天气预报、微博明星粉丝可以应用这种经典模型。</span>

	<span>![](/attachment/201303/31/22312037_1364725030Jp0W.png)

</span>

	<span style="font-size:9.0pt;line-height:120%;font-family:黑体;">图<span>4<span> </span></span>发布订阅模型<span></span></span>

	<span style="font-family:黑体;">2.3.4<span>&nbsp;&nbsp; </span></span><span style="font-family:黑体;">推拉模型<span></span></span>

	<span>Server</span><span style="font-family:宋体;">端作为</span><span>Push</span><span style="font-family:宋体;">端，而</span><span>Client</span><span style="font-family:宋体;">端作为</span><span>Pull</span><span style="font-family:宋体;">端，如果有多个</span><span>Client</span><span style="font-family:宋体;">端同时连接到</span><span>Server</span><span style="font-family:宋体;">端，则</span><span>Server</span><span style="font-family:宋体;">端会在内部做一个负载均衡，采用平均分配的算法，将所有消息均衡发布到</span><span>Client</span><span style="font-family:宋体;">端上。与发布订阅模型相比，推拉模型在没有消费者的情况下，发布的消息不会被消耗掉；在消费者能力不够的情况下，能够提供多消费者并行消费解决方案。该模型主要用于多任务并行。</span>

	<span>![](/attachment/201303/31/22312037_1364725120UoAe.png)

</span>

	<span style="font-size:9.0pt;line-height:120%;font-family:黑体;">图<span>5 </span>推拉模型<span></span></span>

	<span style="font-size:12.0pt;line-height:120%;font-family:黑体;">2.4<span> </span></span><span style="font-size:12.0pt;line-height:120%;font-family:黑体;">通信协议<span></span></span>

	<span style="font-family:宋体;">提供进程内、进程间、机器间、广播等四种通信协议。通信协议配置简单，用类似于</span><span>URL</span><span style="font-family:宋体;">形式的字符串指定即可，格式分别为</span><span>inproc://</span><span style="font-family:宋体;">、</span><span>ipc://</span><span style="font-family:宋体;">、</span><span>tcp://</span><span style="font-family:宋体;">、</span><span>pgm://</span><span style="font-family:宋体;">。</span><span>ZeroMQ</span><span style="font-family:宋体;">会自动根据指定的字符串解析出协议、地址、端口号等信息。</span>

	<span style="font-size:14.0pt;line-height:120%;font-family:黑体;">3<span>&nbsp; </span></span><span style="font-size:14.0pt;line-height:120%;font-family:黑体;">工作流程<span></span></span>

	<span>![](/attachment/201303/31/22312037_1364725157VphV.png)

</span>

	<span style="font-size:9.0pt;line-height:120%;font-family:黑体;">图<span>6 </span>基本流程<span></span></span>

	<span style="font-size:14.0pt;line-height:120%;font-family:黑体;">4<span>&nbsp; </span></span><span style="font-size:14.0pt;line-height:120%;font-family:黑体;">性能分析<span></span></span>

	<span style="font-family:宋体;">目前，市面上类似的产品不少，主要有</span><span>4</span><span style="font-family:宋体;">种：</span><span>MSMQ</span><span style="font-family:宋体;">（微软产品）、</span><span>ActiveMQ</span><span style="font-family:宋体;">（</span><span>Java</span><span style="font-family:宋体;">）、</span><span>RabbitMQ(Erlang)</span><span style="font-family:宋体;">、</span><span>ZeroMQ</span><span style="font-family:宋体;">（</span><span>C++</span><span style="font-family:宋体;">）。除</span><span>ZeroMQ</span><span style="font-family:宋体;">外，其它</span><span>3</span><span style="font-family:宋体;">款产品都是一个单独服务或者进程，需要单独安装和运行，且对环境有一定依赖。其中，</span><span>MSMQ</span><span style="font-family:宋体;">在非</span><span>Windows</span><span style="font-family:宋体;">平台下安装非常复杂，</span><span>ActiveMQ</span><span style="font-family:宋体;">需要目标机器上已经安装了</span><span>Java</span><span style="font-family:宋体;">，</span><span>RabbitMQ</span><span style="font-family:宋体;">需要</span><span>Erlang</span><span style="font-family:宋体;">环境。而</span><span>ZeroMQ</span><span style="font-family:宋体;">是以库的形式存在，由应用程序加载、运行即可。但是</span><span>ZeroMQ</span><span style="font-family:宋体;">仅提供非持久性的消息队列。</span>

	<span style="font-family:宋体;">图</span><span>7</span><span style="font-family:宋体;">是来自于</span><span>Internet</span><span style="font-family:宋体;">的性能测试数据。显示的是每秒钟发送和接受的消息数。整个过程共产生</span><span>1</span><span style="font-family:宋体;">百万条</span><span>1K</span><span style="font-family:宋体;">的消息，测试环境为</span><span>Windows Vista</span><span style="font-family:宋体;">。从测试数据可以看出，</span><span>ZeroMQ</span><span style="font-family:宋体;">的性能远远高于其它</span><span>3</span><span style="font-family:宋体;">个</span><span>MQ</span><span style="font-family:宋体;">。</span>

	<span style="font-family:宋体;">但是测试数据仅供参考，因为缺少必须的环境参数和性能指标，比如：</span><span>CPU</span><span style="font-family:宋体;">参数、内存参数、消息模型、通信协议、极限时消耗</span><span>CPU</span><span style="font-family:宋体;">百分比、极限时消耗内存百分比等。</span>

	<span>![](/attachment/201303/31/22312037_1364725293Ce0Y.png)

</span>

	<span style="font-size:9.0pt;line-height:120%;font-family:黑体;">图<span>7<span> </span></span>性能测试<span></span></span>

	<span style="font-size:14.0pt;line-height:120%;font-family:黑体;">5<span>&nbsp; </span></span><span style="font-size:14.0pt;line-height:120%;font-family:黑体;">应用场景<span></span></span>

	<span style="font-family:宋体;">应用</span><span>ZeroMQ</span><span style="font-family:宋体;">的</span><span>Push-Pull</span><span style="font-family:宋体;">模型实现联众游戏服务器的“热插拔”、负载均衡和消息派发。按照如图</span><span>8</span><span style="font-family:宋体;">部署服务器，</span><span>Push</span><span style="font-family:宋体;">端充当</span><span>Gateway</span><span style="font-family:宋体;">，作为一组游戏服务器集群最上层的一个</span><span>Proxy</span><span style="font-family:宋体;">，起负载均衡的作用，所有</span><span>Gameserver</span><span style="font-family:宋体;">作为</span><span>Pull</span><span style="font-family:宋体;">端。当一个请求到达</span><span>Push</span><span style="font-family:宋体;">端（</span><span>Gateway</span><span style="font-family:宋体;">）时，</span><span>Push</span><span style="font-family:宋体;">端根据一定的分配策略将任务派发到</span><span>Pull</span><span style="font-family:宋体;">端（</span><span>Gameserver</span><span style="font-family:宋体;">）。以联众某款游戏</span><span>A</span><span style="font-family:宋体;">为例，游戏</span><span>A</span><span style="font-family:宋体;">刚上线时，预计最大同时在线人数是</span><span>10W</span><span style="font-family:宋体;">，单台</span><span>Gameserver</span><span style="font-family:宋体;">并发处理能力为</span><span>1W</span><span style="font-family:宋体;">，需要</span><span>10</span><span style="font-family:宋体;">台</span><span>Gameserver</span><span style="font-family:宋体;">，由于游戏</span><span>A</span><span style="font-family:宋体;">可玩性非常好，半个月后最大同时在线人数暴增到</span><span>50W</span><span style="font-family:宋体;">，那么不需要在某天的凌晨将</span><span>Gateway</span><span style="font-family:宋体;">和</span><span>Gameserver</span><span style="font-family:宋体;">停机，只需要随时在机房新添加</span><span>40</span><span style="font-family:宋体;">台</span><span>Gameserver</span><span style="font-family:宋体;">，启动并连接到</span><span>Gateway</span><span style="font-family:宋体;">即可。</span>

	<span>ZeroMQ</span><span style="font-family:宋体;">中对</span><span>Client</span><span style="font-family:宋体;">和</span><span>Server</span><span style="font-family:宋体;">的启动顺序没有要求，</span><span>Gameserver</span><span style="font-family:宋体;">之间如果需要通信的话，</span><span>Gameserver</span><span style="font-family:宋体;">的应用层不需要管理这些细节，</span><span>ZeroMQ</span><span style="font-family:宋体;">已经做了重连处理。</span>

	<span>![](/attachment/201303/31/22312037_1364725343791V.png)

</span>

	<span style="font-size:9.0pt;line-height:120%;font-family:黑体;">图<span>8<span> </span></span>应用场景<span></span></span>

	<span style="font-size:14.0pt;line-height:120%;font-family:黑体;">6<span>&nbsp; </span></span><span style="font-size:14.0pt;line-height:120%;font-family:黑体;">总结<span></span></span>

	<span style="font-size:12.0pt;line-height:120%;font-family:黑体;">6.1<span> </span></span><span style="font-size:12.0pt;line-height:120%;font-family:黑体;">简单<span></span></span>

	<span>1</span><span style="font-family:宋体;">、仅仅提供</span><span>24</span><span style="font-family:宋体;">个</span><span>API</span><span style="font-family:宋体;">接口，风格类似于</span><span>BSD Socket</span><span style="font-family:宋体;">。</span>

	<span>2</span><span style="font-family:宋体;">、处理了网络异常，包括连接异常中断、重连等。</span>

	<span>3</span><span style="font-family:宋体;">、改变</span><span>TCP</span><span style="font-family:宋体;">基于字节流收发数据的方式，处理了粘包、半包等问题，以</span><span>msg</span><span style="font-family:宋体;">为单位收发数据，结合</span><span>Protocol
Buffers</span><span style="font-family:宋体;">，可以对应用层彻底屏蔽网络通信层。</span>

	<span>4</span><span style="font-family:宋体;">、对大数据通过</span><span>SENDMORE/RECVMORE</span><span style="font-family:宋体;">提供分包收发机制。</span>

	<span>5</span><span style="font-family:宋体;">、通过线程间数据流动来保证同一时刻任何数据都只会被一个线程持有，以此实现多线程的“去锁化”。</span>

	<span>6</span><span style="font-family:宋体;">、通过高水位</span><span>HWM</span><span style="font-family:宋体;">来控制流量，用交换</span><span>SWAP</span><span style="font-family:宋体;">来转储内存数据，弥补</span><span>HWM</span><span style="font-family:宋体;">丢失数据的缺陷。</span>

	<span>7</span><span style="font-family:宋体;">、服务器端和客户端的启动没有先后顺序。</span>

	<span style="font-size:12.0pt;line-height:120%;font-family:黑体;">6.2<span> </span></span><span style="font-size:12.0pt;line-height:120%;font-family:黑体;">灵活<span></span></span>

	<span>1</span><span style="font-family:宋体;">、支持多种通信协议，可以灵活地适应多种通信环境，包括进程内、进程间、机器间、广播。</span>

	<span>2</span><span style="font-family:宋体;">、支持多种消息模型，消息模型之间可以相互组合，形成特定的解决方案。</span>

	<span style="font-size:12.0pt;line-height:120%;font-family:黑体;">6.3<span> </span></span><span style="font-size:12.0pt;line-height:120%;font-family:黑体;">跨平台<span></span></span>

	<span style="font-family:宋体;">支持</span><span>Linux</span><span style="font-family:宋体;">、</span><span>Windows</span><span style="font-family:宋体;">、</span><span>OS X</span><span style="font-family:宋体;">等。</span>

	<span style="font-size:12.0pt;line-height:120%;font-family:黑体;">6.4<span> </span></span><span style="font-size:12.0pt;line-height:120%;font-family:黑体;">多语言<span></span></span>

	<span style="font-family:宋体;">可以绑定</span><span>C</span><span style="font-family:宋体;">、</span><span>C++</span><span style="font-family:宋体;">、</span><span>Java</span><span style="font-family:宋体;">、</span><span>.NET</span><span style="font-family:宋体;">、</span><span>Python</span><span style="font-family:宋体;">等</span><span>30</span><span style="font-family:宋体;">多种开发语言。</span>

	<span style="font-size:12.0pt;line-height:120%;font-family:黑体;">6.5<span> </span></span><span style="font-size:12.0pt;line-height:120%;font-family:黑体;">高性能<span></span></span>

	<span style="font-family:宋体;">相对同类产品，性能卓越。</span>

           </div>
